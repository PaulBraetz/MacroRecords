# MacroRecords

*Create detailed C# record types without the boilerplate.*

***
## Feature Overview

Addressing some of what I believe to be shortcomings of C# record types, these are the features `MacroRecords` support:

You may:
- configure the generated constructors visibility
- configure which fields shall be included in the debugger display 
- supply your own constructor(s)
  
You may define each fields:
- name
- type
- visibility
- availability to deconstruction
- support for the `withX(T x)` syntax
- inclusion in the debugger display
- inclusion in validation 

The source code generated (depending on your definitions) includes:
- a constructor
- `DebuggerDisplayAttribute`
- static methods `Create`, `TryCreate`, `IsValid`
- methods `WithX(x value)`
- a `Deconstruct(out x value1, out y value2)`
- an `implicit` conversion operator
- overrides for `Equals(object)`, `GetHashCode()`
- implementations for `Equals(T)`, `==`, `!=`

***
## Installation

*All releases are marked as prerelease until I am confident in their robustness.*

In order to use `MacroRecords`, install the source generator from its Nuget repository: [RhoMicro.MacroRecords](https://www.nuget.org/packages/RhoMicro.MacroRecords/).

The attributes required for instructing the source generator may be found in their own Nuget repository: [RhoMicro.MacroRecords.Attributes](https://www.nuget.org/packages/RhoMicro.MacroRecords/)

***
## Feature Examples

Note: *Samples of generated code have been stripped of comments and regions for legibility. Most members generated by `MacroRecords` are supplied detailed documentation comments. If you feel the documentation to be lacking, please submit an issue. The generated code is also segmented into `#region` fragments for ease of navigation.*

The `MacroRecords` source generator works by generating a partial type declaration. To instruct the generator, annotate your partial type with the `MacroRecordAttribute` found in the `RhoMicro.MacroRecord.Attributes` package.

***
### Using `MacroRecordAttribute`

The `MacroRecordAttribute` is the primary annotation required to instruct the source generator.

The most primitive record you can define using `MacroRecords` therefore looks like this:

```cs
using RhoMicro.MacroRecords;
[MacroRecord]
partial class MyClass{}
```

The source code generated for the above definition will look something like this:
```cs
[DebuggerDisplayAttribute("MyClass")]
partial class MyClass : IEquatable<MyClass>
{
    private MyClass()
    {
    }
    public static MyClass Create()
    {
        return new MyClass();
    }
    public override bool Equals(System.Object obj) => 
        obj is MyClass instance && Equals(instance);
    public bool Equals(MyClass other) => true;
    public override int GetHashCode() => 0;
    public static bool operator ==(MyClass left, MyClass right) => //elided
    public static bool operator !=(MyClass left, MyClass right) => //elided
}
```

Notice that a default private constructor has been generated. By default, `MacroRecords` prefers the factory method pattern implemented by `Create`.
In this simple example, that does not necessarily make much sense, however when introducing validation of fields, it provides more flexibility in controlling how instances of your record type may be created.

***
#### Constructor Generation

Constructor generation is controlled via the `MacroRecordAttribute.Options` property. By default, it is configured so the `RecordOptions.Constructor` flag is set, instructing the generator to emit a constructor.

You may opt out of constructor generation by assigning to the `Options` property the `RecordOptions.None` flag like so:
```cs
[MacroRecord(Options = RecordOptions.None)]
partial class MyClass{}
```

The source code generated for the above definition will look something like this:
```cs
//some members have been elided
[DebuggerDisplayAttribute("MyClass")]
partial class MyClass : IEquatable<MyClass>
{
    public static MyClass Create()
    {
        return new MyClass();
    }
}
```

As you can see, a private default constructor was not generated.
Only the factory method remains.

***
#### Constructor Visibility

You may decide to set the visibility on the generated constructor by assigning a value to the `MacroRecordAttribute.ConstructorVisibility` property like so (the default is `Visibility.Private`):
```cs
[MacroRecord(ConstructorVisibility = Visibility.Internal)]
partial class MyClass{}
```

The source code generated for the above definition will look something like this:
```cs
//some members have been elided
[DebuggerDisplayAttribute("MyClass")]
partial class MyClass : IEquatable<MyClass>
{
    internal MyClass()
    {

    }
    public static MyClass Create()
    {
        return new MyClass();
    }
}
```

***
#### Debugger Display

The `DebuggerDisplayAttribute` generation is controlled via the `MacroRecordAttribute.Options` property. By default, it is configured so the `RecordOptions.DebuggerDisplay` flag is set, instructing the generator to emit the attribute.

You may opt out of this generation by assigning to the `Options` property the `RecordOptions.None` flag like so:
```cs
[MacroRecord(Options = RecordOptions.None)]
partial class MyClass { }
```

The source code generated for the above definition will look something like this:
```cs
//some members have been elided
partial class MyClass : IEquatable<MyClass>
{
}
```

***
#### Combining `MacroRecordAttribute` Options

The `RecordOptions` enum is annotated with the `FlagsAttribute`. You may thus freely combine record options like so:
```cs
[MacroRecord(Options = 
	RecordOptions.Constructor | 
	RecordOptions.DebuggerDisplay)]
partial class MyClass { }
```

***
### Using `FieldAttribute`

The `FieldAttribute` is used to declare members of your record type.
A simple example might look like this:

```cs
[MacroRecord]
[Field(typeof(String), "MyStringField")]
partial class MyClass { }
```

The source code generated for the above definition will look something like this:
```cs
//some members have been elided
[DebuggerDisplayAttribute("MyClass(MyStringField : {MyStringField})")]
partial class MyClass : IEquatable<MyClass>
{
    private MyClass(String in_MyStringField)
    {
        MyStringField = in_MyStringField;
    }
    public readonly String MyStringField;
    public static MyClass Create(String in_MyStringField)
    {
        return new MyClass(in_MyStringField);
    }
    public override bool Equals(Object obj) => 
        obj is MyClass instance && Equals(instance);
    public bool Equals(MyClass other) => 
        other != null && 
        EqualityComparer<String>.Default.Equals(MyStringField, other.MyStringField);
    public override int GetHashCode() => 
        EqualityComparer<String>.Default.GetHashCode(MyStringField);
}
```

A `public` `readonly` field is generated with the declared type and name. The generated constructor assigns it properly and the factory method is also adapted. The `DebuggerDisplayAttribute` takes into account the field, as well as the equality and hashing methods.

***
#### Declare Field Summary

You may supply a description of the field using the `Summary` property:
```cs
[MacroRecord]
[Field(typeof(String), "MyStringField", Summary = "Gets the string value.")]
partial class MyClass { }
```

The source code generated for the above definition will look something like this:
```cs
//some members have been elided
partial class MyClass : IEquatable<MyClass>
{
    /// <summary>
    /// Gets the string value.
    /// </summary>
    public readonly String MyStringField;
}
```

***
#### Declare Field Visibility

You may declare the visibility of the field generated by setting the `Visibility` property (the default is `Visibility.Public`):
```cs
[MacroRecord]
[Field(typeof(String), "MyStringField", Visibility = Visibility.Internal)]
partial class MyClass { }
```

The source code generated for the above definition will look something like this:
```cs
//some members have been elided
partial class MyClass : IEquatable<MyClass>
{
    internal readonly String MyStringField;
}
```

***
#### Declare Field Validation

You may define validation for fields by assigning to the `Options` property the `FieldOptions.Validated` flag:
```cs
[MacroRecord]
[Field(typeof(String), "MyStringField", Options = FieldOptions.Validated)]
partial class MyClass { }
```

The source code generated for the above definition will look something like this:
```cs
//some members have been elided
partial class MyClass : IEquatable<MyClass>
{
    private ref struct ValidateResult
    {
        public bool MyStringFieldIsInvalid;
        public string MyStringFieldError;
    }
    private readonly struct ValidateParameters : IEquatable<ValidateParameters>
    {
        public readonly System.String MyStringField;
    }
    public readonly struct IsValidResult : IEquatable<IsValidResult>
    {
        public readonly bool MyStringFieldIsInvalid;
        public readonly string MyStringFieldError;
    }

    private MyClass(System.String in_MyStringField)
    {
        MyStringField = in_MyStringField;
    }

    public readonly System.String MyStringField;

    static partial void Validate(ValidateParameters parameters, ref ValidateResult result);

    public static IsValidResult IsValid(System.String in_MyStringField)
    {
        //body elided
    }

    public static IsValidResult TryCreate(System.String in_MyStringField, out MyClass? result)
    {
        //body elided
    }

    public static MyClass Create(System.String in_MyStringField)
    {
        //body elided
    }
}
```

The `private` `static` `Validate` method must be implemented by the consuming code. To compile succesfully, the previous definition would have to be adapted like so:
```cs
[MacroRecord]
[Field(typeof(String), "MyStringField", Options = FieldOptions.Validated)]
partial class MyClass 
{
    static partial void Validate(ValidateParameters parameters, ref ValidateResult result)
    {
        //body elided
    }
}
```

The helper types `ValidateParameters` and `ValidateResult` may be used like so:
```cs
static partial void Validate(ValidateParameters parameters, ref ValidateResult result)
{
    if(parameters.MyStringField == null)
    {
        result.MyStringFieldIsInvalid = true;
        result.MyStringFieldError = "MyStringField cannot be null.";
    }
}
```
Important: **`ValidateResult` is a mutable struct, thus you should take special care when moving it ouside of the `Validate` method. The `Validate` method is intended for constraining construction parameters to model-internal integrity rules. It should not depend on complex logic.**

The `public` `static` `IsValid` method makes use of the `Validate` method by returning a readonly view (`IsValidResult`) onto the `ValidateResult` instance manipulated in `Validate`:
```cs
public static IsValidResult IsValid(System.String in_MyStringField)
{
    var result = ValidateResult.Valid;
    var validateParameters = new ValidateParameters(in_MyStringField);
    Validate(validateParameters, ref result);
    return result;
}
```

This `IsValidResult` instance may be used like so:
```cs
MyClass.IsValidResult isValid = MyClass.IsValid(null);
//implicit boolean conversion
if(!isValid)
{
    //obtain detailed state
    var error = isValid.MyStringFieldError;
    var isInvalidValue = isValid.MyStringFieldIsInvalid;

    //deconstruction into detailed state
    var (isInvalid_1, error_1) = isValid;
}
```

The `IsValidResult` type is generated for `MyClass` specifically, as it contains information specific only to that type.

The `TryCreate` method will attempt to create a new instance of your record with the parameters provided. If these do not match the validation defined, it will also return an instance of `IsValidResult`:
```cs
public static IsValidResult TryCreate(System.String in_MyStringField, out MyClass? result)
{
    var validateResult = ValidateResult.Valid;
    var validateParameters = new ValidateParameters(in_MyStringField);
    Validate(validateParameters, ref validateResult);
    var isValid = validateResult.IsValid;
    if (isValid)
    {
        result = new MyClass(in_MyStringField);
    }
    else
    {
        result = null;
    }

    return validateResult;
}
```

The `Create` method will attempt to create a new instance of your record with the parameters provided. If these do not match the validation defined, it will throw an `ArgumentException`:
```cs
public static MyClass Create(System.String in_MyStringField)
{
    var validateResult = ValidateResult.Valid;
    var validateParameters = new ValidateParameters(in_MyStringField);
    Validate(validateParameters, ref validateResult);
    if (!validateResult.IsValid)
    {
        string reasonMessage = null;
        string paramName = null;
        if (validateResult.MyStringFieldIsInvalid)
        {
            reasonMessage = validateResult.MyStringFieldError;
            paramName = "in_MyStringField";
        }

        string reason = null;
        if (reasonMessage != null)
        {
            reason = $" Reason: {reasonMessage}";
        }

        throw new ArgumentException($"The {paramName} provided for creating an instance of MyClass was not valid.{reason}", paramName);
    }

    return new MyClass(in_MyStringField);
}
```

***
#### Support `WithX` Syntax

Enable the generation of `WithX` methods by assigning to the `Options` property the `FieldOptions.SupportsWith` flag:
```cs
[MacroRecord]
[Field(typeof(String), "MyStringField", Options = FieldOptions.SupportsWith)]
[Field(typeof(Int32), "MyIntField")]
partial class MyClass { }
```

The source code generated for the above definition will look something like this:
```cs
//some members have been elided
partial class MyClass : IEquatable<MyClass>
{
    public MyClass WithMyStringField(System.String in_MyStringField) => Create(in_MyStringField, MyIntField);
}
```

***
#### Support Deconstruction

Enable the generation of a deconstruction mechanisms by assigning to the `Options` property the `FieldOptions.Deconstructable` flag:
```cs
[MacroRecord]
[Field(typeof(String), "MyStringField", Options = FieldOptions.Deconstructable)]
[Field(typeof(Int32), "MyIntField")]
partial class MyClass { }
```

The source code generated for the above definition will look something like this:
```cs
//some members have been elided
partial class MyClass : IEquatable<MyClass>
{
    public static implicit operator System.String(MyClass instance) => instance.MyStringField;
}
```

For a single field, the deconstruction mechanism will be the `implicit` conversion operator. Multiple fields may be made avaiable for deconstruction too:
```cs
[MacroRecord]
[Field(typeof(String), "MyStringField", Options = FieldOptions.Deconstructable)]
[Field(typeof(Int32), "MyIntField", Options = FieldOptions.Deconstructable)]
partial class MyClass { }
```

The source code generated for the above definition will look something like this:
```cs
//some members have been elided
partial class MyClass : IEquatable<MyClass>
{    
    public void Deconstruct(out System.String out_MyStringField, out System.Int32 out_MyIntField)
    {
        out_MyStringField = MyStringField;
        out_MyIntField = MyIntField;
    }
}
```
If multiple fields are flagged as deconstructable, the mechanism generated will be the `Deconstruct` method.

***
#### Exclude Fields From The `DebuggerDisplayAttribute`

Exclude a field from the `DebuggerDisplayAttribute` by not assigning to the `Options` property the `FieldOptions.DebuggerDisplay` flag:
```cs
[MacroRecord]
[Field(typeof(String), "MyStringField", Options = FieldOptions.None)]
[Field(typeof(Int32), "MyIntField")]
partial class MyClass { }
```

The source code generated for the above definition will look something like this:
```cs
//some members have been elided
[DebuggerDisplayAttribute("MyClass(MyIntField : {MyIntField})")]
partial class MyClass : IEquatable<MyClass>
{    
}
```

***
#### Combining `FieldOptions`

The `FieldOptions` enum is annotated with the `FlagsAttribute`. You may thus freely combine field options like so:
```cs
[MacroRecord]
[Field(typeof(String), "MyStringField",
    Options = FieldOptions.Validated | FieldOptions.Deconstructable)]
partial class MyClass { }
```

***
## Notes

The generator is still in the development phase. I have implemented some tests already, however there is bound to be some generation bugs. If you encounter *any* issue when generating code using `MacroRecords`, posting an issue explaining your usecase and problem would be greatly appreciated.

I am open to expanding the functionality offered. If you have any ideas, feel free to present them in an issue or pull request.

***
## TODO

- add abstract support

Credits for the name `MacroRecords` go to [Muhamed Karajic](https://github.com/muhamedkarajic).
